"use strict";
var logger_1 = require('./util/logger');
var bundle_1 = require('./bundle');
var helpers_1 = require('./util/helpers');
var config_1 = require('./util/config');
var template_1 = require('./template');
var path_1 = require('path');
var fs_1 = require('fs');
var logger_typescript_1 = require('./util/logger-typescript');
var ts = require('typescript');
function transpile(context) {
    context = config_1.generateContext(context);
    var configFile = getTsConfigPath(context);
    var logger = new logger_1.Logger('transpile');
    return transpileWorker(context, configFile)
        .then(function () {
        logger.finish();
    })
        .catch(function (err) {
        throw logger.fail(err);
    });
}
exports.transpile = transpile;
function transpileUpdate(event, path, context) {
    if (path.endsWith('.ts')) {
        cachedTsFiles = null;
    }
    if (cachedTsFiles) {
        context.tsFiles = cachedTsFiles;
        return Promise.resolve();
    }
    var configFile = getTsConfigPath(context);
    var logger = new logger_1.Logger('transpile update');
    return transpileWorker(context, configFile)
        .then(function (tsFiles) {
        logger.finish();
    })
        .catch(function (err) {
        throw logger.fail(err);
    });
}
exports.transpileUpdate = transpileUpdate;
function transpileWorker(context, configFile) {
    context.tsFiles = null;
    return new Promise(function (resolve, reject) {
        var tsConfig = getTsConfig(context, configFile);
        tsConfig.options.sourceMap = bundle_1.buildJsSourceMaps(context);
        tsConfig.options.declaration = false;
        var tsFileNames = cleanFileNames(context, tsConfig.fileNames);
        var tsFiles = {};
        var host = ts.createCompilerHost(tsConfig.options);
        logger_1.Logger.debug("ts.createProgram, cachedProgram: " + !!cachedProgram);
        var program = ts.createProgram(tsFileNames, tsConfig.options, host, cachedProgram);
        program.emit(undefined, function (path, data) {
            writeCallback(tsFiles, path, data);
        });
        var hasDiagnostics = logger_typescript_1.runDiagnostics(context, program);
        if (hasDiagnostics) {
            // transpile failed :(
            cachedProgram = cachedTsFiles = null;
            reject(new logger_1.BuildError());
        }
        else {
            // transpile success :)
            // cache the typescript program for later use
            cachedProgram = program;
            cachedTsFiles = tsFiles;
            context.tsFiles = tsFiles;
            resolve();
        }
    });
}
exports.transpileWorker = transpileWorker;
function cleanFileNames(context, fileNames) {
    var removeFileName = 'main.prod.ts';
    if (context.isProd) {
        removeFileName = 'main.dev.ts';
    }
    return fileNames.filter(function (f) {
        return (f.indexOf(removeFileName) === -1);
    });
}
function writeCallback(tsFiles, sourcePath, data) {
    sourcePath = path_1.normalize(sourcePath);
    if (helpers_1.endsWith(sourcePath, '.js')) {
        sourcePath = sourcePath.substring(0, sourcePath.length - 3) + '.ts';
        var file = tsFiles[sourcePath];
        if (!file) {
            file = tsFiles[sourcePath] = {};
        }
        file.output = template_1.inlineTemplate(data, sourcePath);
    }
    else if (helpers_1.endsWith(sourcePath, '.js.map')) {
        sourcePath = sourcePath.substring(0, sourcePath.length - 7) + '.ts';
        var file = tsFiles[sourcePath];
        if (!file) {
            file = tsFiles[sourcePath] = {};
        }
        file.map = data;
    }
}
function getTsConfig(context, tsConfigPath) {
    var config = null;
    tsConfigPath = tsConfigPath || getTsConfigPath(context);
    var tsConfigFile = ts.readConfigFile(tsConfigPath, function (path) { return fs_1.readFileSync(path, 'utf8'); });
    if (!tsConfigFile) {
        throw new logger_1.BuildError("tsconfig: invalid tsconfig file, \"" + tsConfigPath + "\"");
    }
    else if (tsConfigFile.error && tsConfigFile.error.messageText) {
        throw new logger_1.BuildError("tsconfig: " + tsConfigFile.error.messageText);
    }
    else if (!tsConfigFile.config) {
        throw new logger_1.BuildError("tsconfig: invalid config, \"" + tsConfigPath + "\"\"");
    }
    else {
        var parsedConfig = ts.parseJsonConfigFileContent(tsConfigFile.config, ts.sys, context.rootDir, {}, tsConfigPath);
        if (parsedConfig.errors && parsedConfig.errors.length) {
            parsedConfig.errors.forEach(function (d) {
                logger_typescript_1.printDiagnostic(context, d);
            });
            throw new logger_1.BuildError();
        }
        config = {
            options: parsedConfig.options,
            fileNames: parsedConfig.fileNames,
            typingOptions: parsedConfig.typingOptions,
            raw: parsedConfig.raw
        };
    }
    return config;
}
exports.getTsConfig = getTsConfig;
var cachedProgram = null;
var cachedTsFiles = null;
function getTsConfigPath(context) {
    return path_1.join(context.rootDir, 'tsconfig.json');
}
exports.getTsConfigPath = getTsConfigPath;
