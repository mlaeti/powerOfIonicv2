"use strict";
var fs_1 = require('fs');
var logger_1 = require('./util/logger');
var config_1 = require('./util/config');
var path_1 = require('path');
var tslint_1 = require('tslint');
var logger_tslint_1 = require('./util/logger-tslint');
var worker_client_1 = require('./worker-client');
var Linter = require('tslint');
var fs = require('fs');
function lint(context, configFile) {
    context = config_1.generateContext(context);
    configFile = config_1.getUserConfigFile(context, taskInfo, configFile);
    return worker_client_1.runWorker('lint', context, configFile)
        .catch(function (err) {
        throw new logger_1.BuildError(err);
    });
}
exports.lint = lint;
function lintWorker(context, configFile) {
    return new Promise(function (resolve, reject) {
        configFile = configFile || config_1.getConfigValueDefault(taskInfo.fullArgConfig, taskInfo.shortArgConfig, taskInfo.envConfig, path_1.join(context.rootDir, 'tslint.json'), context);
        logger_1.Logger.debug("tslint config: " + configFile);
        fs_1.access(configFile, function (err) {
            if (err) {
                // if the tslint.json file cannot be found that's fine, the
                // dev may not want to run tslint at all and to do that they
                // just don't have the file
                logger_1.Logger.debug("tslint: " + err);
                resolve();
                return;
            }
            var logger = new logger_1.Logger('lint');
            lintApp(context, configFile)
                .then(function () {
                // always finish and resolve
                logger.finish();
                resolve();
            }).catch(function () {
                // always finish and resolve
                logger.finish();
                resolve();
            });
        });
    });
}
exports.lintWorker = lintWorker;
function lintApp(context, configFile) {
    var program = tslint_1.createProgram(configFile, context.srcDir);
    var files = tslint_1.getFileNames(program);
    var promises = files.map(function (file) {
        return lintFile(context, program, file);
    });
    return Promise.all(promises);
}
function lintFile(context, program, file) {
    return new Promise(function (resolve) {
        if (isMpegFile(file)) {
            // silly .ts files actually being video files
            resolve();
            return;
        }
        fs.readFile(file, 'utf8', function (err, contents) {
            if (err) {
                // don't care if there was an error
                // let's just move on with our lives
                resolve();
                return;
            }
            try {
                var configuration = tslint_1.findConfiguration(null, file);
                var linter = new Linter(file, contents, {
                    configuration: configuration,
                    formatter: null,
                    formattersDirectory: null,
                    rulesDirectory: null,
                }, program);
                var lintResult = linter.lint();
                logger_tslint_1.printFailures(context, lintResult.failures);
            }
            catch (e) {
                logger_1.Logger.debug("Linter " + e);
            }
            resolve();
        });
    });
}
function isMpegFile(file) {
    var buffer = new Buffer(256);
    buffer.fill(0);
    var fd = fs.openSync(file, 'r');
    try {
        fs.readSync(fd, buffer, 0, 256, null);
        if (buffer.readInt8(0) === 0x47 && buffer.readInt8(188) === 0x47) {
            logger_1.Logger.debug("tslint: " + file + ": ignoring MPEG transport stream");
            return true;
        }
    }
    finally {
        fs.closeSync(fd);
    }
    return false;
}
var taskInfo = {
    fullArgConfig: '--tslint',
    shortArgConfig: '-l',
    envConfig: 'ionic_tslint',
    defaultConfigFile: '../tslint'
};
